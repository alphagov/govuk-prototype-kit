{
  "name": "mu2",
  "description": "A Mustache template engine for Node.js",
  "keywords": [
    "template",
    "mustache"
  ],
  "version": "0.5.20",
  "homepage": "http://github.com/raycmorgan/mu",
  "author": {
    "name": "RayMorgan",
    "email": "ray@rumgr.com"
  },
  "main": "lib/mu",
  "licenses": [
    {
      "type": "MIT",
      "url": "https://raw.github.com/raycmorgan/Mu/master/LICENSE"
    }
  ],
  "readme": "# Mu - a fast, streaming Node.js Mustache engine\n\nWarning: This version is not API compatible with 0.1.\n\n## Install\n\nI have had some issues with my npm auth and got it in a bit of a rut, so for\nnow you have to:\n\n    npm install mu2\n\n## Issues\n\nCurrently mu does not support changing the tag form ({{ }} to say <% %>).\n\n## Usage\n\nThere are a few ways to use mu 0.5. Here is the simplest:\n```javascript\nvar mu = require('mu2'); // notice the \"2\" which matches the npm repo, sorry..\n\nmu.root = __dirname + '/templates'\nmu.compileAndRender('index.html', {name: \"john\"})\n  .on('data', function (data) {\n    console.log(data.toString());\n  });\n```\nHere is an example mixing it with the http module:\n```javascript\nvar http = require('http')\n  , util = require('util')\n  , mu   = require('mu2');\n\nmu.root = __dirname + '/templates';\n\n  http.createServer(function (req, res) {\n\n  var stream = mu.compileAndRender('index.html', {name: \"john\"});\n  util.pump(stream, res);\n\n}).listen(8000);\n```\nTaking that last example here is a little trick to always compile the templates\nin development mode (so the changes are immediately reflected).\n```javascript\nvar http = require('http')\n  , util = require('util')\n  , mu   = require('mu2');\n\nmu.root = __dirname + '/templates';\n\nhttp.createServer(function (req, res) {\n\n  if (process.env.NODE_ENV == 'DEVELOPMENT') {\n    mu.clearCache();\n  }\n\n  var stream = mu.compileAndRender('index.html', {name: \"john\"});\n  util.pump(stream, res);\n\n}).listen(8000);\n```\n## API\n\n    mu.root\n\n      A path to lookup templates from. Defaults to the working directory.\n\n\n    mu.compileAndRender(String templateName, Object view)\n\n      Returns: Stream\n\n      The first time this function is called with a specific template name, the\n      template will be compiled and then rendered to the stream. Subsequent\n      calls with the same template name will use a cached version of the compiled\n      template to improve performance (a lot).\n\n\n    mu.compile(filename, callback)\n\n      Returns nil\n      Callback (Error err, Any CompiledTemplate)\n\n      This function is used to compile a template. Usually you will not use it\n      directly but when doing wierd things, this might work for you. Does not\n      use the internal cache when called multiple times, though it does add the\n      compiled form to the cache.\n\n\n    mu.compileText(String name, String template, Function callback)\n\n      Returns nil\n      Callback (err, CompiledTemplate)\n\n      Similar to mu.compile except it taks in a name and the actual string of the\n      template. Does not do disk io. Does not auto-compile partials either.\n\n\n    mu.render(Mixed filenameOrCompiledTemplate, Object view)\n\n      Returns Stream\n\n      The brother of mu.compile. This function takes either a name of a template\n      previously compiled (in the cache) or the result of the mu.compile step.\n\n      This function is responsible for transforming the compiled template into the\n      proper output give the input view data.\n\n\n    mu.renderText(String template, Object view, Object partials)\n\n      Returns Stream\n\n      Like render, except takes a template as a string and an object for the partials.\n      This is not a very performant way to use mu, so only use this for dev/testing.\n\n\n    mu.clearCache(String templateNameOrNull)\n\n      Clears the cache for a specific template. If the name is omitted, clears all cache.\n\n\n\n",
  "_id": "mu2@0.5.20",
  "_from": "mu2@0.5.20"
}
