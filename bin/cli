#!/usr/bin/env node

const fs = require('fs-extra')
const path = require('path')

const { spawn, exec } = require('../lib/exec')
const { parse } = require('./utils/argv-parser')
const { prepareMigration, preflightChecks } = require('../migrator')
const { npmInstall, packageJsonFormat, getPackageVersionFromPackageJson, splitSemverVersion } = require('./utils')
const { recursiveDirectoryContentsSync } = require('../lib/utils')
const { appViewsDir } = require('../lib/utils/paths')

// Avoid requiring any kit server code at the top-level as we might want to
// change environment variables below.

const currentDirectory = process.cwd()
const kitRoot = path.join(__dirname, '..')
const kitVersion = require('../package.json').version
const kitProjectName = require('../package.json').name

const argv = parse(process.argv, {
  booleans: ['no-version-control', 'verbose', 'running-within-create-script', 'use-njk-extensions']
})

const verboseLogger = !argv.options.verbose
  ? () => {}
  : function () {
    console.log('[verbose]', ...arguments)
  }

const progressLogger = function () {
  if (argv.command === 'init') {
    const versionOfInstaller = argv.options['created-from-version']
    if (!versionOfInstaller) {
      return
    }
    const version = splitSemverVersion(versionOfInstaller)
    if (version.major === 13 && version.minor < 2) {
      return
    }
  }

  console.log(' - ', ...arguments)
}

const npmrc = `
audit=false
`.trimStart()

const gitignore = `
# Node.js ignores
node_modules/

# Prototype ignores - per-user
.tmp/
.env
migrate.log
usage-data-config.json

# General ignores
.DS_Store
.idea
`.trimStart()

const packageJson = {
  scripts: {
    dev: 'govuk-prototype-kit dev',
    serve: 'govuk-prototype-kit serve',
    start: 'govuk-prototype-kit start'
  }
}

async function updatePackageJson (packageJsonPath) {
  let newPackageJson = Object.assign({}, packageJson)
  newPackageJson = Object.assign(newPackageJson, await fs.readJson(packageJsonPath))
  await fs.writeJson(packageJsonPath, newPackageJson, packageJsonFormat)
}

function displaySuccessMessage () {
  console.log('')
  console.log('Prototype created')
  if (argv.paths.length > 0) {
    console.log('')
    console.log('Change to your prototype directory:')
    console.log(`  cd ${argv.paths[0]}`)
  }
  console.log('')
  console.log('To run your prototype:')
  console.log('  npm run dev')
  console.log('')
}

async function initialiseGitRepo () {
  const noVersionControlArg = 'no-version-control'
  if (argv.options[noVersionControlArg]) {
    verboseLogger(`User specified --${noVersionControlArg}, skipping.`)
    return
  }
  progressLogger('Initialising git')
  try {
    await exec('git init --initial-branch=main && git add -A .', {})
  } catch (e) {
    verboseLogger('Failed to initialise git')
    verboseLogger(e.message)
    verboseLogger(e.errorOutput)
    return
  }

  const failSilently = () => {}

  const commitMessage = 'Create prototype'
  await exec(`git commit -am "${commitMessage}"`)
    .catch(() =>
      exec(`git -c "user.email=gov.uk-prototype@digital.cabinet-office.gov.uk" -c "user.name=GOV.UK Prototype Kit" commit -am "${commitMessage}"`)
    )
    .catch(failSilently)
}

function usage () {
  const prog = 'npx govuk-prototype-kit'
  console.log(`
${prog} <command>

Usage:

${prog} create
${prog} create /exact/location/to/create/in
${prog} create relative/location/to/create/in

${prog} dev
${prog} serve
${prog} start

${prog} migrate`
  )
}

function getInstallLocation () {
  const chosenPath = argv.paths[0]
  if (chosenPath) {
    if (path.isAbsolute(chosenPath)) {
      return chosenPath
    }
    return path.resolve(chosenPath)
  }
  return currentDirectory
}

function getChosenKitDependency () {
  const defaultValue = 'govuk-prototype-kit'
  const versionRequested = argv.options.version || argv.options.v

  if (!versionRequested) {
    return defaultValue
  }

  if (versionRequested === 'local' || versionRequested === 'local-symlink') {
    return kitRoot
  } else if (versionRequested) {
    if (versionRequested.match(/\d+\.\d+\.\d+/) ||
      versionRequested.match(/\d+\.\d+\.\d+-alpha\.\d+]/) ||
      versionRequested.match(/\d+\.\d+\.\d+-beta\.\d+]/)
    ) {
      return `${defaultValue}@${versionRequested}`
    } else {
      return versionRequested
    }
  }
  return defaultValue
}

// do some heuristics to try and catch situations where a user has run
// `npm start` (the wrong command) locally and warn them.
function warnIfNpmStart (argv, env) {
  if (
    argv.command === 'start' && // if user ran serve script then assume they know what they want
    env.NODE_ENV !== 'production' && // some hosting services set NODE_ENV
    env.PORT === undefined && // some hosting services set PORT
    env.PASSWORD === undefined // user should have set PASSWORD when setting up hosting
  ) {
    console.warn('Warning: It looks like you may have run the command `npm start` locally.')
    console.warn('try running `npm run dev`')
    console.warn()
    console.warn('If you see the above warning when trying to host your prototype online,')
    console.warn('it may be that your hosting service needs further configuration.')
    console.warn()
  }
}

function writeEmptyPackageJson (installDirectory) {
  return fs.writeJson(path.join(installDirectory, 'package.json'), {})
}

function getArgumentsToPassThrough () {
  const additionalArgs = Object.keys(argv.options).map(name => `--${name}="${argv.options[name]}"`)
  return additionalArgs
}

async function initialiserRequiresOldInitSyntax () {
  const version = await getPackageVersionFromPackageJson(path.join(getInstallLocation(), 'node_modules', 'govuk-prototype-kit', 'package.json'))

  const requiresOldInitSyntax = version.major === 13 && version.minor < 2
  return requiresOldInitSyntax
}

async function runCreate () {
  // Install as a two-stage bootstrap process.
  //
  // In stage one (`create`) we create an empty project folder and install
  // govuk-prototype-kit and govuk-frontend, then bootstrap stage two from
  // the newly installed package.
  //
  // In stage two (`init`) we do the actual setup of the starter files.
  //
  // Doing it this way means we can be sure the version of the cli matches
  // the version of the kit the user ends up with. Try to put as much logic
  // as possible into stage two; stage one should ideally be able to install
  // any future version of the kit.

  verboseLogger('Cli running from', __filename)

  console.log('')

  const installDirectory = getInstallLocation()
  const kitDependency = getChosenKitDependency()

  await fs.ensureDir(installDirectory)
  if ((await fs.readdir(installDirectory)).length > 0) {
    console.error(`Directory ${installDirectory} is not empty, please specify an empty location.`)
    process.exitCode = 3
    return
  }

  console.log('Creating your prototype')

  await writeEmptyPackageJson(installDirectory)

  progressLogger('Installing dependencies')

  await npmInstall(installDirectory, [kitDependency, 'govuk-frontend', '@govuk-prototype-kit/common-templates'])

  if ((argv.options.version || argv.options.v) === 'local-symlink') {
    const dependencyInstallLocation = path.join(installDirectory, 'node_modules', kitProjectName)
    await fs.remove(dependencyInstallLocation)
    await fs.ensureSymlink(kitDependency, dependencyInstallLocation)
  }

  let runningWithinCreateScriptFlag = '--running-within-create-script'

  if (await initialiserRequiresOldInitSyntax()) {
    runningWithinCreateScriptFlag = '--'
  }

  progressLogger('Setting up your prototype')

  await spawn('npx', ['govuk-prototype-kit', 'init', runningWithinCreateScriptFlag, installDirectory, `--created-from-version=${kitVersion}`, ...(getArgumentsToPassThrough())], {
    cwd: installDirectory,
    stdio: 'inherit'
  })
    .then(displaySuccessMessage)
}

async function createStarterFiles (installDirectory) {
  await fs.copy(path.join(kitRoot, 'prototype-starter'), installDirectory)

  async function addToConfigFile (key, value) {
    const configFileLocation = path.join(installDirectory, 'app', 'config.json')
    const config = await fs.readJson(configFileLocation)
    config[key] = value
    await fs.writeJson(configFileLocation, config, { spaces: 2 })
  }

  function renameAllHtmlFilesToNjk () {
    return recursiveDirectoryContentsSync(appViewsDir)
      .filter(filePath => filePath.endsWith('.html'))
      .map(filePath => fs.move(
        path.join(appViewsDir, filePath),
        path.join(appViewsDir, filePath.substring(0, filePath.length - '.html'.length) + '.njk')
      ))
  }

  if (argv.options['use-njk-extensions']) {
    await Promise.all([
      addToConfigFile('useNjkExtensions', true),
      ...renameAllHtmlFilesToNjk()
    ])
  }
}

async function runInit () {
  // `init` is stage two of the install process (see above), it should be
  // called by `create` with the correct arguments.

  if (!argv.options['running-within-create-script'] && process.argv[3] !== '--') {
    usage()
    process.exitCode = 2
    return
  }

  const installDirectory = getInstallLocation()

  const copyFile = (fileName) => fs.copy(path.join(kitRoot, fileName), path.join(installDirectory, fileName))

  await Promise.all([
    createStarterFiles(installDirectory),
    fs.writeFile(path.join(installDirectory, '.gitignore'), gitignore, 'utf8'),
    fs.writeFile(path.join(installDirectory, '.npmrc'), npmrc, 'utf8'),
    copyFile('LICENCE.txt'),
    updatePackageJson(path.join(installDirectory, 'package.json'))
  ])
    .then(initialiseGitRepo)
}

async function runMigrate () {
  // migrate as a two-stage bootstrap process.
  //
  // In stage one we install govuk-prototype-kit, then bootstrap stage two
  // from the newly installed package.
  //
  // In stage two (with the magic arguments) we do the actual migration with
  // the starter files.
  //
  // Doing it this way means we can be sure the version of the cli matches
  // the version of the kit the user ends up with. Try to put as much logic
  // as possible into stage two; stage one should ideally be able to migrate
  // to any future version of the kit.
  if (process.argv[3] !== '--') {
    // stage one
    const kitDependency = getChosenKitDependency()
    const projectDirectory = process.cwd()

    const preflightChecksPassed = await preflightChecks()

    if (!preflightChecksPassed) {
      process.exitCode = 1
      return
    }

    await prepareMigration(kitDependency, projectDirectory)

    await spawn('npx', ['govuk-prototype-kit', 'migrate', '--', projectDirectory], {
      stdio: 'inherit'
    })
  } else {
    // stage two
    if (process.argv.length !== 5) {
      usage()
      process.exitCode = 2
      return
    }

    const projectDirectory = process.argv[4]

    await Promise.all([
      updatePackageJson(path.join(projectDirectory, 'package.json')),
      fs.writeFile(path.join(projectDirectory, '.npmrc'), npmrc, 'utf8'),
      fs.access(path.join(projectDirectory, '.gitignore'))
        .catch(() => fs.writeFile(path.join(projectDirectory, '.gitignore'), gitignore, 'utf8'))
    ])

    await require('../migrator').migrate()
  }
}

async function runDev () {
  console.log(`GOV.UK Prototype Kit ${kitVersion}`)
  console.log('')
  console.log('starting...')

  await require('../lib/dev-server').runDevServer()
}

function runServe () {
  warnIfNpmStart(argv, process.env)
  process.env.NODE_ENV = process.env.NODE_ENV || 'production'
  require('../lib/build.js').generateAssetsSync()
  require('../listen-on-port')
}

async function convertToEsm () {
  const dir = path.join(getInstallLocation())
  const packageJsonPath = path.join(dir, 'package.json')
  if (!fs.exists(dir)) {
    console.error(`There is no directory ${dir}`)
    process.exit(10)
  }
  if (!fs.exists(packageJsonPath)) {
    console.error(`There is no package json at ${packageJsonPath}`)
    process.exit(10)
  }
  await fs.move(path.join(dir, 'bin', 'cli'), path.join(dir, 'bin', 'cli.js'))
  const jsFiles = await Promise.all(recursiveDirectoryContentsSync(dir)
    .filter(filename => !filename.startsWith('node_modules') && !filename.startsWith('prototype-starter') && !filename.includes('assets/javascripts') && filename.endsWith('.js'))
    .map(async filename => ({
      filename,
      contents: await fs.readFile(path.join(dir, filename), 'utf8')
    }))
  )
  const transformations = [
    {
      find: 'const config = require(\'../config\').getConfig()',
      replace: 'const configInclude = require(\'../config\')\nconst config = configInclude.getConfig()'
    },
    {
      find: /require\('(.*\/(migrator|utils))'\)/g,
      replace: 'require(\'$1/index\')'
    },
    {
      find: /require\('(\.[^']+)'\)/g,
      replace: 'require(\'$1.js\')'
    },
    {
      find: /require\('(\.[^']+\.json)\.js'\)/g,
      replace: 'readJsonFileAsPartOfMigration(path.join(__dirname, \'$1\'))'
    },
    {
      find: /const ([^{=]+) = require\((\'[\w\.\-\/]+\')\)/g,
      replace: 'import * as $1 from $2'
    },
    {
      find: /const \{([^}]+)} = require\((\'[\w\.\/\-]+\')\)/g,
      replace: 'import {$1} from $2'
    },
    {
      find: /import \{(.*)\s(\w+): (\w+)\s(.*)}/g,
      replace: 'import {$1 $2 as $3}'
    },
    {
      find: 'from \'fs\'.promises',
      replace: 'from \'fs/promises\''
    },
    {
      find: /module\.exports = (\{[^{}]+})/g,
      replace: 'export default $1'
    },
    {
      find: 'module.exports =',
      replace: 'const exportValue ='
    },
    {
      find: /(export\s+\{[^}]+)\s+(\w+)\s*:\s*(\w+)/g,
      replace: '$1 $3 as $2'
    },
    {
      find: /import \* as (\w+) (from '[^']+')\.(\w+)/g,
      replace: 'import { $3 as $1 } $2'
    },
    {
      find: /(from '[^']+\.json')/g,
      replace: '$1 assert { type: \'json\' }'
    },
    {
      find: /const (\w+) = export default/g,
      replace: 'let $1\nexport default $1\n$1 =',
    },
    {
      find: /(const \w+ = )const (exportValue =)/g,
      replace: 'let exportValue\n$1$2'
    }
  ]
  await Promise.all(jsFiles.map(async fileInfo => {
    let contents = fileInfo.contents
    const fullPath = path.join(dir, fileInfo.filename)
    transformations.forEach(({ find, replace }) => {
      contents = contents.replaceAll(find, replace)
    })
    if (fileInfo.filename === 'lib/utils/paths.js') {
      let exportVars = [] 
      const setExportRegex = /^exports\.(\w+) =/
      const setExportReplace = 'const $1 ='
      const useExportRegex = /exports\.(\w+)/
      const useExportReplace = '$1'
      contents = contents.split('\n').map(line => {
        const result = line.match(setExportRegex)
        if (result) {
          exportVars.push(result[1])
        }
        return line.replace(setExportRegex, setExportReplace).replace(useExportRegex, useExportReplace)
      }).join('\n')
      contents += 'export {' + exportVars.map(varName => `\n  ${varName}`).join(',') + '\n}\n'
    }
    if (contents.includes('__dirname')) {
      const polyfillLines = []
      polyfillLines.push(`import path from 'node:path'`)
      polyfillLines.push(`import { fileURLToPath } from 'node:url'`)
      polyfillLines.push('')
      polyfillLines.push(`const __filename = fileURLToPath(import.meta.url)`)
      polyfillLines.push(`const __dirname = path.dirname(__filename)`)
      if (contents.includes('readJsonFileAsPartOfMigration')) {
        polyfillLines.push('import * as fsExtraAsPartOfMigration from \'fs-extra\'')
        polyfillLines.push('const readJsonFileAsPartOfMigration = fsExtraAsPartOfMigration.readJsonSync')
      }
      let lines = contents.split('\n')
      const startLines = []
      while(lines[0].startsWith('#!') || lines[0].startsWith('"use')) {
        startLines.push(lines.shift())
      }
      lines = lines.filter(line => line !== 'import * as path from \'path\'') 
      contents = startLines.concat(polyfillLines).concat(lines).join('\n')
    }
    if (contents.includes('const exportValue =') && !fileInfo.filename.endsWith('migration-steps.js') && !fileInfo.filename.endsWith('upgrade-steps.js')) {
      contents += 'export default exportValue\n'
    }
    await fs.writeFileSync(fullPath, contents)
  }))
  console.log(jsFiles.map(file => file.filename))
  const packageContents = await fs.readJson(packageJsonPath)
  packageContents.type = 'module'
  packageContents.bin['govuk-prototype-kit'] = 'bin/cli.js'
  await fs.writeJson(packageJsonPath, packageContents, packageJsonFormat)
}

;(async () => {
  verboseLogger(`Using kit version [${kitVersion}] for command [${argv.command}]`)
  verboseLogger('Argv:', argv)
  switch (argv.command) {
    case 'create':
      return runCreate()
    case 'init':
      return runInit()
    case 'dev':
      return runDev()
    case 'start':
      return runServe()
    case 'serve':
      return runServe()
    case 'migrate':
      return runMigrate()
    case 'version':
      console.log(kitVersion)
      break
    case 'convert-to-esm':
      return convertToEsm()
    default:
      usage()
      process.exitCode = 2
  }
})()
